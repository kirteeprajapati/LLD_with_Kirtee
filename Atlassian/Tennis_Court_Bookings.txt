Tennis Court Bookings

We are tasked with assigning tennis court bookings to courts, while respecting overlaps and optional maintenance time.

Problem Details

Input: A list of bookings, each with:

(id, start_time, end_time)


Output: A mapping from court number â†’ list of booking IDs assigned to that court.

Constraints:

Bookings on the same court cannot overlap.

Optionally, after each booking, the court may require maintenance time before the next booking can start.

Goal is to minimize the number of courts needed.

Examples
Example 1 â€” Basic Assignment

Input:

bookings = [
    (1, 0, 10),
    (2, 5, 14),
    (3, 19, 30)
]
maintenance_time = 0


Output:

{
  1: [1, 3],  # Court 1: booking 1 (0-10), booking 3 (19-30)
  2: [2]      # Court 2: booking 2 (5-14)
}


Explanation:

Booking 1 and 2 overlap â†’ need separate courts.

Booking 3 can reuse Court 1 because it starts after booking 1 ends.

Example 2 â€” With Maintenance

Input:

bookings = [
    (1, 0, 10),
    (2, 12, 18),
    (3, 9, 15)
]
maintenance_time = 2


Output:

{
  1: [1, 2],  # Court 1: booking 1 (0-10), maintain 2 units â†’ next booking starts at 12 â†’ booking 2 is OK
  2: [3]      # Court 2: booking 3 overlaps with 1 â†’ new court
}

Approach

Sort bookings by start time.

Use a min-heap (priority queue) to track the earliest available court end time.

For each booking:

If the earliest available court (including maintenance time) is free â†’ assign to that court.

Otherwise â†’ open a new court.

Maintain court assignment mapping.

Time complexity: 
ğ‘‚
(
ğ‘
log
â¡
ğ‘
)
O(NlogN), dominated by sorting and heap operations.

Function Signature
def assign_courts(bookings: List[Tuple[int, int, int]], maintenance_time: int) -> Dict[int, List[int]]:
    pass
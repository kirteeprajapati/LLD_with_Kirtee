Knight Moves on Phone
Problem Overview

You are working with a phone keypad:

1 2 3
4 5 6
7 8 9
  0


A chess knight moves in "L" shapes: 2 in one direction and 1 perpendicular.

We are interested in sequences of digits a knight can reach under specific constraints.

Part 1 — Minimum Moves

Goal: Determine the minimum number of knight moves required to go from a starting digit to a target digit.

Function Signature
def knight_moves(start: int, end: int, exact_moves: int):
    pass


start: Starting digit (0-9)

end: Ending digit (0-9)

exact_moves: If 0, return the minimum number of moves. If >0, return all paths with exactly this many moves (used in Part 2).

Example
start = 5
end = 6
exact_moves = 0


Output:

4


Explanation:
One minimum path: 5 -> 6 -> 5 -> 4 -> 1 requires 4 moves.

Part 2 — Paths with Exact Moves

Goal: Generate all sequences of digits reachable from the starting digit using exactly k moves.

Example
start = 0
exact_moves = 7


Output:

["16039", "46420", "13369"]


Explanation:
Three sequences exist of length 7 starting from 0:

1 -> 6 -> 0 -> 3 -> 9 → "16039"

4 -> 6 -> 4 -> 2 -> 0 → "46420"

1 -> 3 -> 3 -> 6 -> 9 → "13369"

Constraints

0 <= start, end <= 9

0 <= exact_moves <= 16

Notes

You may use BFS/DFS for minimum moves or exact moves generation.

Map the keypad to coordinates for easier knight movement calculation:

positions = {
    1: (0,0), 2: (0,1), 3: (0,2),
    4: (1,0), 5: (1,1), 6: (1,2),
    7: (2,0), 8: (2,1), 9: (2,2),
    0: (3,1)
}


Valid knight moves: (±2, ±1) and (±1, ±2) within the keypad bounds.